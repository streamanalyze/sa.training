-- **************************************
-- Training session 1
-- OSQL Basics
--     All these examples are taken from the official docs:
--     https://studio.streamanalyze.com/docs/guides/tutorial/basic-functions
--     The docs contain more detailed information about the examples.
-- **************************************

-- Usage: place cursor at a line and press shift-return to run it


-- -----------------
-- Simple queries
-- -----------------

-- Simple query
sin(3.14/2)*cos(3.14);


-- -----------------
-- Helper functions
-- -----------------

-- Read documentation for 'sin' function
doc('sin');

-- You can run several OSQL statements by separating them with a ;
doc('atan2');
doc('cos');

-- Doc function works with pattern matching
doc('_tan%');

-- You can read the source code of a function
sourcecode('atan2');

-- And get the signature
signature('atan%');

-- OSQL supports overloaded functions (different arguments)
signature('range');

-- You can get the version of SA Engine
system_version();


-- -----------------
-- Session variables
-- -----------------

-- Assigne the session variable pi
set :pi = 3.14;

-- Use the session variable in a computation
sin(:pi/2)*cos(:pi);


-- -----------------
-- Database tables
-- -----------------

-- Tables are created by the 'create table' statement
create table Constants(name   Charstring,
                       value  Real,
                       unique (name));

-- Tables are populated using SQL's 'insert into' statement
insert into Constants values('pi',     3.14),
                            ('e',      2.71),
                            ('freeze', 0.0),
                            ('boil',   100.0);


-- -----------------
-- Queries
-- -----------------

-- Queries filter out and transform objects fulfilling some
-- specific properties from collections of objects

-- A populated table can be queried by SQL's 'select' statement

select * from Constants;

select value from Constants where name = 'pi';

select sin(value/2)*cos(value) from Constants where name = 'pi';


-- Tables can be updated using SQL's 'update' statement

update Constants set value=asin(1)*2 where name = 'pi';

update Constants set value=exp(1) where name = 'e';

select * from Constants;

-- Get the name and value of constant that gets rounded to 3
select name, value
  from Constants
 where round(value) = 3;


-- -----------------
-- Set Queries
-- -----------------

-- Set of odd elements between 1-10
select i
  from Integer i
 where i in range(10)
   and mod(i,2) = 1;

-- Set of divisors for the integer 143
select d
  from Integer d, Integer n
 where d in range(2,ceil(n/2))
   and 0 = mod(n,d)
   and n = 143;

-- This query returns a bag rather than a set
select floor(i/2)
  from Integer i
 where i in range(10);

-- A function applied on a set in a query is called for
-- each element of the set
select sin(range(10));

-- Queries having no from or where clauses are called
-- expressions and can be specified without the keyword select
sin(range(10));

-- You can visualize with the '//plot:' directive

//plot: Line plot
sin(range(10));

-- The order of the objects returned by set queries is not
-- guaranteed, unless you specify it using SQL's 'order by'
select x
  from Real x
 where x in sin(range(10))
 order by x;

-- Queries may return sets of tuples where each tuple group
-- two or more comma separated values
select i, i+1
  from Integer i
 where i in range(5);


-- -----------------
-- Values queries
-- -----------------

-- Values queries construct explicit bags using the
-- notation 'values v1, v2, ...'
values 1,3,2,4;

-- A bag with a single value is logically the same as the
-- single value itself
values 123;

-- Tuples can be specified in values queries by using the
-- notation '(e1,e2,...,en)'
values (1,'a'),(2,'b'),(3,'c');

-- A tuple with a single value is logically the same as the
-- single value itself
values ('a');

values ('a'),('b'),('c');

-- Bags in expressions can be expressed by enclosing a
-- values query in parentheses
set :mybag = (values 1,2,2,3);

:mybag;


-- -----------------
-- Case expressions
-- -----------------

-- Case expressions compute values having different
-- definitions depending on conditions
select case when x <= -40 then "too cold"
            when x < 0    then "freezing"
            when x < 18   then "cold"
            when x < 23   then "plesant"
            when x < 40   then "hot"
            else "too hot"
        end
  from Real x
 where x in 10 * range(-4,4);

-- A test succeeds unless its value is null or false
case when sqrt(-1)    then 1
     when 2 < sqrt(2) then 2
     else 0 end;


-- -----------------
-- AND, OR and NOT
-- -----------------

-- Return the set of values in the bag (values 1,2,3,4,5) being
-- less than 3 or larger than 4
select i
  from Integer i
 where i in (values 1,2,3,4,5)
   and (i<3 or i>4);

-- To negate disjunctive logical expressions we can use the
-- expression 'not l' that returns true when 'l' is true
select i
  from Integer i
 where i in (values 1,2,3,4,5)
   and not i <= sqrt(10);


-- -----------------
-- Defining functions
-- -----------------

-- Analysis models are defined in terms of OSQL functions. You can
-- define your own OSQL functions by the 'create function' statement.
create function ctof(Real c) -> Real
  /* Convert a Celsius degree `c` to Fahrenheit */
  as c * 9 / 5 + 32;

ctof(10);

-- You can use your OSQL functions in queries
select ctof(value)
  from Constants
 where name = 'boil';

-- You can also create derived functions, which are functions defined
-- by a query
create function constant(Charstring c) -> Real
  as select value from Constants where name = c;

ctof(constant('boil'));

-- This derived function computes the divisors of integer 'n'
create function divisors(Integer n) -> Bag of Integer
  as select d
       from Integer d
      where d in range(2,ceil(n/2))
        and 0 = mod(n,d);

divisors(143);

-- Case expressions can be used in function definitions
create function signum(Real x) -> Integer
  as case when x > 0 then 1
          when x = 0 then 0
          else -1 end;

signum(-3.1);


-- -----------------
-- Temporal functions
-- -----------------

-- The built-in function local_time() returns the current
-- local wall time as an ISO time stamp string
local_time();

-- The current UTC time stamp string is returned by calling
utc_time();

-- The function now() returns the wall time as a time point
-- which is an object of type Timeval that internally represents
-- the number of microseconds since new year 1970
now();


-- -----------------
-- Sequences
-- -----------------

-- The data type Vector represents finite sequences of objects
-- with the usual [...] notation

-- A vector of four integers
[1,2,3,4];

-- A vector of two vectors
[[1.1,2.0],[3,4]];

-- A vector of a string and a number
['Tore',55];

-- You can access vector element v_i by the notation v[i]
set :v = [2,4,6];

:v[2];


-- -----------------
-- Select vector queries
-- -----------------

-- A select vector query works exactly like a regular set query
-- with the difference that it returns a vector of values rather
-- than a bag of values
select Vector of sin(i)
  from Integer i
 where i in range(3)
 order by i;

-- The difference between a vector and bag is that the order of
-- the elements in a vector is important while it is undefined in bags
select Vector of sin(i)
  from Integer i
 where i in range(3)
 order by sin(i);

-- The following select vector query removes 2 from the vector
-- [1,2,3,2,4]
select Vector of a[i]
  from Vector a, Integer i
 where a = [1,2,4,2,3]
   and a[i] != 2
 order by i;


-- -----------------
-- Vector operators and functions
-- -----------------

-- The number of elements in a vector
dim([1, 3, 2]);

-- Vector addition
[1,4,3,2] + [1,5,6,7];

-- Element wise vector multiplication
[1, 2, 3, 4] .* [5, 6, 7, 8];

-- Combining vectors and scalars
[1,4,3,2] - [0,2,3,4] + 1;

-- Vector aggregation functions
sum([1, 2, 3, 4]);

avg([1, 2, 3, 4]);

stdev([1, 2, 3, 4]);

median([1, 4, 2, 3]);


-- -----------------
-- Arrays
-- -----------------

-- An array is a multi-dimensional cube of numbers. It is
-- represented by type Array. Using arrays is much more efficient
-- than using objects of type Vector
array([[1,2,3],[4,5,6]]);

-- The number of dimensions of an array is called its rank
set :a = array([[1,2,3],[4,5,6]]);

rank(:a);

-- Value of row 2 and column 3 in 'a'
:a[2,3];

-- You can select slices of arrays by specifying the wildcard
-- character * in array index positions
:a[*,3];


-- -----------------
-- Array format
-- -----------------

-- The elements of an array have a format that specifies their
-- binary representations in memory
array('I16',[1,2,3,4]);

array('F32',[1,2,3,4]);


-- -----------------
-- Array shape
-- -----------------

-- An array also has a shape being a vector of the number of
-- elements in each of its dimensions
shape(array([1,2,3]));

shape(array([[1,2,3],[4,5,6]]));


-- -----------------
-- Array operators and functions
-- -----------------

-- Addition
array([[1,2],[3,4]]) + array([[2,3],[6,7]]);

-- Add column one and three of ':a'
:a[*,1] + :a[*,3];

-- The total sum of array elements
sum(array([[1, 2], [3, 4]]));

-- Element-wise multiplication
array([[1,2],[3,4]]) .* array([[2,3],[6,7]]);

-- Scalar product
dot(array([[1,2],[3,4]]),array([[4,5],[6,7]]));

-- Matrix multiplication
matmul(array([[1,2,3]]),array([[1,2],
                               [3,4],
                               [5,6]]));


-- -----------------
-- Select array queries
-- -----------------

-- Analogous to set queries and select vector queries, a select
-- array query returns a single array as result
select Array[i..4,j..5] of U8 e
 where e = i + j;


-- -----------------
-- Aggregate functions
-- -----------------

-- The aggregate function sum() adds the elements in a bag, vector
-- or array
sum(range(200)/2);

sum(array([1, 2, 3, 4]));

sum(array([[1, 2], [3, 4]]));

sum([1, 2, 3, 4]);

-- The function avg() computes the mean value of the elements in a
-- bag, vector or array
avg(array([1, 2, 3, 4]));

avg(array([[1, 2], [3, 4]]));

avg([1, 2, 3, 4]);

-- The function stdev() computes the standard deviation of the
-- elements in a bag, vector or array
stdev([1, 2, 3, 4]);

-- The function max() computes the largest element in a bag, vector
-- or array
max(array([2, 4, 1, 1, 4, 3]));

max([2, 4, 1, 1, 4, 3]);

-- The function min() computes the smallest element in a bag, vector
-- or array
min(array([2, 4, 1, 1, 4, 3]));

min([2, 4, 1, 1, 4, 3]);

-- The function argmax() computes the first largest element in a
-- vector or array
argmax(array([2, 4, 1, 1, 4, 3]));

argmax([2, 4, 1, 1, 4, 3]);

-- The function argmin() computes the first smallest element in a
-- vector or array
argmin(array([2, 4, 1, 1, 4, 3]));

argmin([2, 4, 1, 1, 4, 3]);

-- Aggregate functions over bags can be used in SQL queries
select sum(value) from Constants;


-- -----------------
-- The reduce function
-- -----------------

-- The reduce function provides a closed formula mechanism for defining
-- incremental aggregations over bags, vectors, arrays, and streams
reduce((values 1,2,3,4),'+');

-- Sum the elements of a 2x2 matrix
reduce(array([[1,2],[3,4]]),'+');

-- Return the largest element in a vector
reduce([1,2,3,4],'max');

-- Sum the odd natural numbers up to 20
reduce((select i
          from Integer i
         where i in range(20)
           and mod(i,2)=0),
       '+');


-- -----------------
-- Boolean and null values
-- -----------------

-- The constant null is used to represent unknown or missing values.
-- A Boolean null value is regarded as false. Thus, the query 2<1 returns
-- null, while 2>1 return true. The only object of type Boolean is thus
-- true. The constant false is defined as null casted to type Boolean
sum([1,2,null]);

-- Passing null as argument in a function call will return null without
-- calling the function
sin(sqrt(-1));

-- The expression 'exists x' returns true if the expression 'x' is not empty
exists range(1,10000000000);

exists sqrt(-1);

-- Analogously, the expression 'not exists x' returns true if the expression
-- 'x' is empty
not exists sqrt(-1);

-- Often it is practical to use a default value instead of null. For this
-- the coalesce(x1,...,xn) expression can be used. It returns the first
-- xiâ€‹ not being null
coalesce(sqrt(-1), ln(-1), 1) + 1;

-- To replace all nulls in a vector use whennull
whennull([1,2,null,3], 0) + 2;

-- Returns the set of prime numbers among 197,143,2
select n
  from Integer n
 where n in (values 197,143,2)
   and not exists divisors(n);


-- -----------------
-- Distance functions
-- -----------------

-- Euclidean distance
euclid([0,0], [2,3]);

euclid(array([0,0]), array([2,3]));

-- Manhattan distance
manhattan([0,0], [2,3]);

manhattan(array([0,0]), array([2,3]));

-- Minkowsky distance (Manhattan)
minkowski([1,2],[3,4], 1);

-- Minkowsky distance (Euclidean)
minkowski([1,2],[3,4], 2);

-- Minkowsky distance (Chebyshev)
minkowski([1,2],[3,4], +inf);


-- -----------------
-- The Fast Fourier Transform
-- -----------------

-- Real-valued Fast Fourier Transform
rfft(array([1.0, 2, 3, 4]));

-- Inverse
irfft(rfft(array([1.0, 2, 3, 4])));

-- Works on Vectors but slower as it converts to array
rfft([1.0, 2, 3, 4]);


-- -----------------
-- Undo changes
-- -----------------

-- You can undo all definitions in a session by the command 'rollback'
create function myadd(Integer i)->Integer as i+1;

rollback;

myadd(1);

-- You can make a save point by executing the command commit. The next
-- rollback will stop at the commit
create function myadd(Integer i)->Integer as i+1;

commit;

rollback;

myadd(1);


